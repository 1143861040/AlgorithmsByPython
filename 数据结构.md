# 数据结构
## 一些概念
> 数据结构就是研究数据的**逻辑结构**和**物理结构**以及它们之间**相互关系**，并对这种结构定义相应的运算，而且确保经过这些运算后所得到的新结构仍然是原来的结构类型。1. 数据：所有能被输入到计算机中，且能被计算机处理的符号的集合。是计算机操作的对象的总称。
2. 数据元素：数据（集合）中的一个“个体”，数据及结构中讨论的**基本**单位
3. 数据项：数据的不可分割的最小单位。一个数据元素可由若干个数据项组成。
4. 数据类型：在一种程序设计语言中，变量所具有的数据种类。整型、浮点型、字符型等等

1. 逻辑结构：数据之间的相互关系。
	* 集合 结构中的数据元素除了同属于一种类型外，别无其它关系。
	* 线性结构 数据元素之间一对一的关系
	* 树形结构 数据元素之间一对多的关系
	* 图状结构或网状结构 结构中的数据元素之间存在多对多的关系
2. 物理结构/存储结构：数据在计算机中的表示。物理结构是描述数据具体在内存中的存储（如：顺序结构、链式结构、索引结构、希哈结构）等

1. 算法五个特性： 有穷性、确定性、可行性、输入、输出
2. 算法设计要求：正确性、可读性、健壮性、高效率与低存储量需求
3. 设计算法在执行时间是需要考虑：算法选用的规模、问题的规模
4. 时间复杂度：算法的执行时间与原操作**执行次数**之和成正比。O(1)<O(logn)<O(n)<O(nlogn)<O(n2)<O(n3)。O(2n)<O(n!)<O(nn)
5. 空间复杂度：若输入数据所占空间只取决于问题本身，和算法无关，则只需要分析**除输入和程序之外的辅助变量所占额外空间**。

## 线性表
线性表是一种典型的线性结构。头结点无前驱有一个后继，尾节点无后继有一个前驱。

1. 线性表的顺序存储结构：把线性表的结点按逻辑顺序依次存放在一组地址连续的存储单元里。用这种方法存储的线性表简称顺序表。**数组**。
	* 便于线性表的构造和任意元素的访问
	* 插入：插入新结点，之后结点后移。平均时间复杂度:O(n)
	* 删除：删除节点，之后结点前移。平均时间复杂度:O(n)
2. 线性链表：用一组任意的存储单元来依次存放线性表的结点，这组存储单元即可以是连续的，也可以是不连续的，甚至是零散分布在内存中的任意位置上的。因此，链表中结点的逻辑次序和物理次序不一定相同。为了能正确表示结点间的逻辑关系，在存储每个结点值的同时，还必须存储指示其后继结点的地址。data域是数据域，用来存放结点的值。next是指针域（亦称链域），用来存放结点的直接后继的地址（或位置）。
	* **单链表**中每个结点的存储地址是存放在其前趋结点next域中，而开始结点无前趋，故应设头指针head指向开始结点。同时，由于最后一个结点无后继，故结点的指针域为空，即NULL。头插法建表(逆序)、尾插法建表(顺序)
		* 查找：只能从链表的头指针出发，顺链域next逐个结点往下搜索，直到搜索到第i个结点为止。因此，**链表不是随机存取结构**。
		* 插入：先找到表的第i-1的存储位置，然后插入。新结点先连后继，再连前驱。
		* 删除：首先找到a_i-1的存储位置p。然后令p–>next指向a_i的直接后继结点，即把a_i从链上摘下。最后释放结点a_i的空间.r=p->next;p->next=r->next;delete r;
	* 静态链表：用一维数组来实现线性链表，这种用一维数组表示的线性链表，称为静态链表。静态：体现在表的容量是一定的。（数组的大小）；链表：插入与删除同前面所述的动态链表方法相同。
	* 静态链表是用数组实现的，是顺序的存储结构，在物理地址上是连续的，而且需要预先分配大小。动态链表是用申请内存函数（C是malloc,C++是new）动态申请内存的，所以在链表的长度上没有限制。动态链表因为是动态申请内存的，所以每个节点的物理地址不连续，要通过指针来顺序访问。静态链表在插入、删除时也是通过修改指针域来实现的，与动态链表没有什么分别
	* 循环链表：是一种头尾相接的链表。其特点是无须增加存储量，仅对表的链接方式稍作改变，即可使得表处理更加方便灵活。
		* 在单链表中，将终端结点的指针域NULL改为指向表头结点的或开始结点，就得到了单链形式的循环链表，并简单称为**单循环链表**。由于循环链表中没有NULL指针，故涉及遍历操作时，其终止条件就不再像非循环链表那样判断p或p—>next是否为空，而是判断它们是否等于某一指定指针，如头指针或尾指针等。
	* 双向链表:在单链表的每个结点里再增加一个指向其直接前趋的指针域prior。这样就形成的链表中有两个方向不同的链。双链表一般由头指针唯一确定的，将头结点和尾结点链接起来构成循环链表，并称之为双向链表。设指针p指向某一结点，则双向链表结构的对称性可用下式描述：p—>prior—>next=p=p—>next—>prior
		* 插入：先搞定插入节点的前驱和后继，再搞定后结点的前驱，最后搞定前结点的后继。## 栈和队列
### 栈
栈(Stack)是限制在表的一端进行插入和删除运算的线性表，通常称插入、删除的这一端为栈顶(Top)，另一端为栈底(Bottom)。先进后出。

1. 顺序存储栈：顺序存储结构
2. 链栈：链式存储结构。插入和删除操作仅限制在链头位置上进行。栈顶指针就是链表的头指针。

应用，[代码](https://github.com/Jack-Lee-Hiter/AlgorithmsByPython/blob/master/Stack.py)：

1. 进制转换2. 括号匹配的检验
3. 行编辑程序
4. 迷宫求解：若当前位置“可通”，则纳入路径，继续前进;若当前位置“不可通”，则后退，换方向继续探索;若四周“均无通路”，则将当前位置从路径中删除出去。
5. 表达式求解：前缀、中缀、后缀。
	* 操作数之间的相对次序不变;
	* 运算符的相对次序不同;
	* 中缀式丢失了括弧信息，致使运算的次序不确定
	* 前缀式的运算规则为:连续出现的两个操作数和在它们之前且紧靠它们的运算符构成一个最小表达式
	* 后缀式的运算规则为:运算符在式中出现的顺序恰为表达式的运算顺序;每个运算符和在它之前出现且紧靠它的两个操作数构成一个最小表达式。
6. 实现递归：多个函数嵌套调用的规则是：后调用先返回。

### 队列
队列(Queue)也是一种运算受限的线性表。它只允许在表的一端进行插入，而在另一端进行删除。允许删除的一端称为队头(front)，允许插入的一端称为队尾(rear)。先进先出。

1. 顺序队列：顺序存储结构。当头尾指针相等时队列为空。在非空队列里，头指针始终指向队头前一个位置，而尾指针始终指向队尾元素的实际位置
2. 循环队列。在循环队列中进行出队、入队操作时，头尾指针仍要加1，朝前移动。只不过当头尾指针指向向量上界（MaxSize-1）时，其加1操作的结果是指向向量的下界0。除非向量空间真的被队列元素全部占用，否则不会上溢。因此，除一些简单的应用外，真正实用的顺序队列是循环队列。故队空和队满时头尾指针均相等。因此，我们无法通过front=rear来判断队列“空”还是“满”
3. 链队列：链式存储结构。限制仅在表头删除和表尾插入的单链表。显然仅有单链表的头指针不便于在表尾做插入操作，为此再增加一个尾指针，指向链表的最后一个结点。

1.队空条件：rear==front，但是一般需要引入新的标记来说明栈满还是栈空，比如每个位置布尔值
2.队满条件：(rear+1) %QueueSIze==front，其中QueueSize为循环队列的最大长度
3.计算队列长度：（rear-front+QueueSize）%QueueSize
4.入队：（rear+1）%QueueSize
5.出队：（front+1）%QueueSize

## 串
串(String)是零个或多个字符组成的有限序列。长度为零的串称为**空串**(Empty String)，它不包含任何字符。通常将仅由一个或多个空格组成的串称为**空白串**(Blank String) 注意：空串和空白串的不同，例如“  ”和“”分别表示长度为1的空白串和长度为0的空串。

串的表示和实现：

1. 定长顺序存储表示。静态存储分配的顺序表。
2. 堆分配存储表示。存储空间是在程序执行过程中动态分配而得。所以也称为动态存储分配的顺序表
3. 串的链式存储结构。

串匹配：将主串称为目标串，子串称之为模式串。蛮力法匹配。[KMP算法](http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html)匹配。[Boyer-Moore算法](https://github.com/Jack-Lee-Hiter/Introduction-to-The-Design-and-Analysis-of-Algorithms/blob/master/Boyer-Moore/BM%20by%20swift)匹配。

## 数组和广义表
数组和广义表可看成是一种特殊的线性表，其特殊在于: 表中的元素本身也是一种线性表。内存连续。根据下标在O(1)时间读/写任何元素。

**二维数组，多维数组，广义表、树、图都属于非线性结构**

### 数组
数组的顺序存储：行优先顺序；列优先顺序。数组中的任一元素可以在相同的时间内存取，即顺序存储的数组是一个随机存取结构。矩阵的压缩：

1. 对称矩阵、三角矩阵：直接存储矩阵的上三角或者下三角元素。**注意区分i>=j和i<j的情况**
2. 对角矩阵：除了主对角线和主对角线相邻两侧的若干条对角线上的元素之外，其余元素皆为零。
3. 稀疏矩阵：非零元素个数远小于矩阵元素总数。
	* 三元组顺序表。三元组顺序表虽然节省了存储空间，但时间复杂度比一般矩阵转置的算法还要复杂，同时还有可能增加算法的难度。因此，此算法仅适用于t<<m*n的情况。
	* 稀疏矩阵在采用压缩存储后将会失去随机存储的功能。因为在这种矩阵中，非零元素的分布是没有规律的，为了压缩存储，就将每一个非零元素的值和它所在的行、列号做为一个结点存放在一起，这样的结点组成的线性表中叫三元组表，它已不是简单的向量，所以无法用下标直接存取矩阵中的元素。

### 广义表
广义表（Lists，又称列表）是线性表的推广。广义表是n(n≥0)个元素a1,a2,a3,…,an的有限序列，其中a_i或者是原子项，或者是一个广义表。若广义表LS（n>=1)非空，则a1是LS的表头，其余元素组成的表(a2,…an)称为LS的表尾。广义表的元素可以是广义表，也可以是原子，广义表的元素也可以为空。

例子：

1. A=（）——A是一个空表，其长度为零。2. B=（e）——表B只有一个原子e，B的长度为1。3. C=（a,(b,c,d))——表C的长度为2，两个元素分别为原子a和子表(b,c,d)。4. D=（A，B，C）——表D的长度为3，三个元素都是广义 表。显然，将子表的值代入后，则有D=(( ),(e),(a,(b,c,d)))。
5. E=（a,E）——这是一个递归的表，它的长度为2，E相当于一个无限的广义表E=(a,(a,(a,(a,…)))).

三个结论：

1. 广义表的元素可以是子表，而子表的元素还可以是子表。由此，广义表是一个多层次的结构，可以用图形象地表示
2. 广义表可为其它表所共享。例如在上述例4中，广义表A，B，C为D的子表，则在D中可以不必列出子表的值，而是通过子表的名称来引用。
3. 广义表的递归性考点：

1. 广义表是0个或多个单因素或子表组成的有限序列，广义表可以是自身的子表，广义表的长度n>=0，所以可以为空表。广义表的**同级**元素(直属于同一个表中的各元素)具有**线性**关系
2. 广义表的表头为空，并不代表该广义表为空表。广义表()和(())不同。前者是长度为0的空表，对其不能做求表头和表尾的运算；而后者是长度为l的非空表(只不过该表中惟一的一个元素是空表)，对其可进行分解，得到的表头和表尾均是空表()
3. 已知广义表LS＝((a,b,c),(d,e,f)),运用head和tail函数取出LS中原子e的运算是head(tail(head(tail(LS)))。根据表头、表尾的定义可知：任何一个非空广义表的表头是表中第一个元素，它可以是原子，也可以是子表，而其**表尾必定是子表**。也就是说，广义表的head操作，取出的元素是什么，那么结果就是什么。但是tail操作取出的元素外必须加一个表——“（）“。tail(LS)＝((d,e,f))；head(tail(LS))=(d,e,f)；tail(head(tail(LS)))=(e,f)；head(tail(head(tail(LS))))=e。
4. 二维以上的数组其实是一种特殊的广义表
5. 在（非空）广义表中：1、表头head可以是原子或者一个表 2、表尾tail一定是一个表 3.广义表难以用顺序存储结构 4.广义表可以是一个多层次的结构

## 树和二叉树
一种**非线性**结构。树是递归结构，在树的定义中又用到了树的概念。

基本术语：

1. 树结点：包含一个数据元素及若干指向子树的分支；2. 孩子结点：结点的子树的根称为该结点的孩子；3. 双亲结点：B结点是A结点的孩子，则A结点是B结点的双亲；4. 兄弟结点：同一双亲的孩子结点；5. 堂兄结点：同一层上结点；6. 结点层次：根结点的层定义为1；根的孩子为第二层结点，依此类推；7. 树的高（深）度：树中最大的结点层8. 结点的度：结点子树的个数9. 树的度： 树中最大的结点度。10. 叶子结点：也叫终端结点，是度为0的结点；11. 分枝结点：度不为0的结点（非终端结点）；12. 森林：互不相交的树集合；13. 有序树：子树有序的树，如：家族树；14. 无序树：不考虑子树的顺序；

### 二叉树
二叉树可以为空。二叉树结点的子树要区分左子树和右子树，即使只有一棵子树也要进行区分，说明它是左子树，还是右子树。这是二叉树与树的最主要的差别。

性质：

1. 在二叉树的第 i 层上至多有2^(i-1) 个结点。
2. 深度为 k 的二叉树上至多含 2^(k)-1 个结点（k≥1）
3. 对任何一棵二叉树，若它含有n_0 个叶子结点、n_2 个度为 2 的结点，则必存在关系式：n_0 = n_2+1。
4. 具有 n 个结点的完全二叉树的深度为⎣log_2 n⎦+1 。
5. n个结点的二叉树中，完全二叉树具有最小的路径长度。
6. 如果对一棵有n个结点的完全二叉树的结点按层序编号,则对任一结点i（1<=i<=n),有：
	* 如果i＝1，则结点i无双亲，是二叉树的根；如果i>1，则其双亲的编号是 i/2(整除）。
	* 如果2i>n，无左孩子；否则，其左孩子是结点2i。
	* 如果2i＋1>n，则结点i无右孩子；否则，其右孩子是结点2i＋1。

二叉树的存储结构

1. 顺序存储结构：仅仅适用于满或完全二叉树，结点之间的层次关系由性质5确定。
2. 二叉链表法：每个节点存储左子树和右子树。三叉链表：左子树、右子树、父节点

#### **遍历二叉树和线索二叉树**

遍历二叉树：使得每一个结点均被访问一次，而且仅被访问一次。非递归的遍历实现要利用栈。

* 先序遍历DLR：根节点->左子树->右子树
* 中序遍历LDR：左子树->根节点->右子树
* 后续遍历LRD：左子树->右子树->根节点

线索二叉树：对二叉树所有结点做某种处理可在遍历过程中实现；检索（查找）二叉树某个结点，可通过遍历实现；如果能将二叉树线索化，就可以简化遍历算法，提高遍历速度，目的是加快查找结点的前驱或后继的速度。

如何线索化？以中序遍历为例，若能将中序序列中每个结点前趋、后继信息保存起来，以后再遍历二叉树时就可以根据所保存的结点前趋、后继信息对二叉树进行遍历。对于二叉树的线索化，实质上就是遍历一次二叉树，只是在遍历的过程中，检查当前结点左，右指针域是否为空，若为空，将它们改为指向前驱结点或后继结点的线索。**前驱就是在这一点之前走过的点，不是下一将要去往的点**。加上结点前趋后继信息（结索）的二叉树称为**线索二叉树**。n个结点的线索二叉树上每个结点有2个指针域（指向左孩子和右孩子），总共有2n个指针域；一个n个结点的树有n-1条边，那么空指针域= 2n - (n-1) = n + 1，即线索数为n+1。指针域tag为0，存放孩子指针，为1，存放前驱/后继节点指针。

线索树下结点x的前驱与后继查找：设结点x相应的左（右）标志是线索标志，则lchild(rchild)就是前驱(后继），否则：

* LDR--前驱：左子树中最靠右边的结点；后继：右子树中最靠左边的结点
* LRD--前驱：右子树的根，若无右子树，为左子树跟。后继：x是根，后继是空；x是双亲的右孩子、x是双亲的左孩子，但双亲无右孩子，双亲是后继；x是双亲的左孩子，双亲有右孩子，双亲右子树中最左的叶子是后继
* DLR--对称于LRD线索树---将LRD中所有左右互换，前驱与后继互换，得到DLR的方法。
* 为简化线索链表的遍历算法，仿照线性链表，为线索链表加上一头结点，约定：	* 头结点的lchild域：存放线索链表的根结点指针；	* 头结点的rchild域: 中序序列最后一个结点的指针；	* 中序序列第一结点lchild域指向头结点;	* 中序序列最后一个结点的rchild域指向头结点;

中序遍历的线索二叉树以及线索二叉树链表示意图
![xiansuobinarytree](http://images.cnitblog.com/blog/311549/201309/13230006-d365a5866c094ee7b3897a1675d34716.jpg)

一棵左右子树均不空的二叉树在前序线索化后,其中空的链域的个数是1。**前序和后续线索化后空链域个数都是1，中序是2**。二叉树在线索化后，仍不能有效求解的问题是前序求前序先驱，后序求后序后继。

中序遍历的顺序为：左、根、右，所以对于每一非空的线索，左子树结点的后继为根结点，右子树结点的前驱为根结点，再递归的执行上面的过程，可得非空线索均指向其祖先结点。**在中序线索二叉树中,每一非空的线索均指向其祖先结点**。在二叉树上加上结点前趋、后继线索后，可利用线索对二叉树进行遍历,此时，**不需栈，也不需递归**。基本步骤：

1. p=T->lchild; p指向线索链表的根结点；
2. 若线索链表非空，循环：	* 循环，顺着p左孩子指针找到最左下结点；访问之； 	* 若p所指结点的右孩子域为线索，p的右孩子结点即为后继结点循环： p=p->rchild； 并访问p所指结点；（在此循环中，顺着后继线索访问二叉树中的结点）	* 一旦线索“中断”，p所指结点的右孩子域为右孩子指针，p=p->rchild，使 p指向右孩子结点；

### 树和森林
树的存储结构：

1. 双亲表示法
2. 孩子表示法
3. 利用图表示树
4. 孩子兄弟表示法（二叉树表示法）：链表中每个结点的两指针域分别指向其第一个孩子结点和下一个兄弟结点

将树转化成二叉树：右子树一定为空

1. 加线：在兄弟之间加一连线2. 抹线：对每个结点，除了其左孩子外，去除其与其余孩子之间的关系3. 旋转：以树的根结点为轴心，将整树顺时针转45°

森林转换成二叉树：

1. 将各棵树分别转换成二叉树2. 将每棵树的根结点用线相连3. 以第一棵树根结点为二叉树的根

树与转换后的二叉树的关系：转换后的二叉树的先序对应树的先序遍历；转换后的二叉树的中序对应树的后序遍历### 哈弗曼树/霍夫曼树
一些概念

1. 路径：从一个祖先结点到子孙结点之间的分支构成这两个结点间的路径；2. 路径长度：路径上的分支数目称为路径长度；3. 树的路径长度：从根到每个结点的路径长度之和。4. 结点的权：根据应用的需要可以给树的结点赋权值；5. 结点的带权路径长度：从根到该结点的路径长度与该结点权的乘积；6. 树的带权路径长度=树中所有叶子结点的带权路径之和；通常记作  WPL=∑ w<sub>i</sub>×l<sub>i</sub> 7. 哈夫曼树：假设有n个权值(w1 ,  w2  , … , wn  )，构造有n个叶子结点的二叉树，每个叶子结点有一个 wi 作为它的权值。则带权路径长度最小的二叉树称为哈夫曼树。